<!DOCTYPE html>

<html>

<head>
	<title>Jenga - Physijs</title>
	
	<link rel="stylesheet" type="text/css" href="css/styles.css" />
	
	<script type="text/javascript" src="js/three.min.js"></script>
	<script type="text/javascript" src="js/stats.js"></script>
	<script type="text/javascript" src="js/physi.js"></script>
	<script src="js/ImprovedNoise.js"></script>
	<script src="js/effects/OculusRiftEffect.js"></script>
	<script src="js/controls/FirstPersonControls.js"></script>
	<script src="js/controls/OculusControls.js"></script>
	<script src="https://js.leapmotion.com/leap-0.6.4.js"></script>
	<script src="https://js.leapmotion.com/leap-plugins-0.1.12.js"></script>
	<script
	src="https://code.jquery.com/jquery-3.2.1.slim.min.js"
	integrity="sha256-k2WSCIexGzOj3Euiig+TlR8gA0EmPjuc79OEeY5L45g="
	crossorigin="anonymous">
</script>
<!-- Custom code -->
<!-- <script type="text/javascript" src="js/engine.js"></script> -->
<script type="text/javascript">

	var currentframe = 0; //most recent leap data
	var leapcontroller; 	// for getting leap data
	'use strict';
	
	Physijs.scripts.worker = 'js/physijs_worker.js';
	Physijs.scripts.ammo = 'ammo.js';
	
	var test_block, draw_hands, init_world, initEventHandling, draw_test_block, currmousex, currmousey, render, createTower, loader,
	renderer, render_stats, physics_stats, scene, dir_light, am_light, camera,
	table, blocks = [], lhand, rhand,lbock,rblock,table_material, block_material, intersect_plane,
	selected_block = null, mouse_position = new THREE.Vector3, block_offset = new THREE.Vector3, _i, _v3 = new THREE.Vector3;
	var touched_block;
	var lastfingertippos;
	// var boneboxes = [];
	var boneMeshes = [];
	var oldpos;
	var lineGeometry;
 //    var jointMeshes = [];
 var checking_collisions = false;
	//from effect demo
	var realcamera;
	var guiVisible = true;
	var mesh, effect, controls, oculuscontrol;
	var clock = new THREE.Clock();
	var mousehasbeenmoved = false;
	var last_relv;
	var pinching = false;
	function init_bone_meshes() {
		console.log("----------------------");
		for (var i = 0; i < 40; i++) {
			var m = new Physijs.SphereMesh(
				new THREE.SphereGeometry(0.25),
				Physijs.createMaterial(new THREE.MeshBasicMaterial({color: 0xff0000}), 1, 1),
				1
				);
			m.addEventListener( 'collision', function( other_object, relative_velocity, relative_rotation, contact_normal ) {
				// `this` has collided with `other_object` with an impact speed of `relative_velocity` and a rotational force of `relative_rotation` and at normal `contact_normal`
				if(checking_collisions){
					if(other_object.geometry.type != "SphereGeometry"){
						touched_block = other_object;
						//console.log("collided! with other:");
						//console.log(other_object);
						//last_relv = relative_velocity;
					}
				}
				
			});
			boneMeshes.push(m);
		}
		console.log("BoneMeshes");
		console.log(boneMeshes);
	}
	function init_leap() {
		console.log("Initialized Leap");
		leapcontroller = new Leap.Controller({enableGestures: true})
		.use('screenPosition')
		.connect()
		.on('frame', function(frame){
			//console.log(frame);	//will get a frame, no need to check
			currentframe = frame; //update a reference to the current frame for use in setting in the phys sim
			//lhand = currentframe.
			//console.log(currentframe);
			
		})
		


	}	
	function init_renderer(){
		//set renderer
		renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.shadowMap.enabled = true;
		renderer.shadowMapSoft = true;
		document.getElementById( 'viewport' ).appendChild( renderer.domElement );
	}
	function init_camera(){
		//Init camera ////////////////////
		camera = new THREE.PerspectiveCamera(
			35,

			window.innerWidth / window.innerHeight,
			1,
			1000
			);
		camera.position.set( 10, 10, 25 );
		camera.lookAt(new THREE.Vector3( 0, 7, 0 ));
	}
	function init_stats (argument) {
		//init stats module
		render_stats = new Stats();
		render_stats.domElement.style.position = 'absolute';
		render_stats.domElement.style.top = '1px';
		render_stats.domElement.style.zIndex = 100;
		document.getElementById( 'viewport' ).appendChild( render_stats.domElement );
		//init stats module
		physics_stats = new Stats();
		physics_stats.domElement.style.position = 'absolute';
		physics_stats.domElement.style.top = '50px';
		physics_stats.domElement.style.zIndex = 100;
		document.getElementById( 'viewport' ).appendChild( physics_stats.domElement );
	}
	function init_effect(){
		//Added oculus effect ////////////////////////////////////
		effect = new THREE.OculusRiftEffect( renderer, { worldScale: 1 } );
		effect.setSize( window.innerWidth, window.innerHeight );
	}
	function init_scene(){

		scene = new Physijs.Scene({ fixedTimeStep: 1 / 30});
		scene.add( camera ); //order is weird
		//scene = Leap.loopController.plugins.boneHand.scene;
		// setting up
		scene.setGravity(new THREE.Vector3( 0, -30, 0 ));
		scene.addEventListener(
			'update',
			function() {

				if ( selected_block !== null ) {
					
					_v3.copy( mouse_position ).add( block_offset ).sub( selected_block.position ).multiplyScalar( 5 );
					_v3.y = 0;
					selected_block.setLinearVelocity( _v3 );
					
					// Reactivate all of the blocks
					_v3.set( 0, 0, 0 );
					for ( _i = 0; _i < blocks.length; _i++ ) {
						blocks[_i].applyCentralImpulse( _v3 );
					}
				}

				//scene.simulate( undefined, 1 );
				//physics_stats.update();
			}
			);
		
		
		
		lineGeometry = new THREE.Geometry();
		lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -300 ) );

		var line = new THREE.Line(
			lineGeometry,
			new THREE.LineBasicMaterial({ color: 0x0000ff })
			);
		scene.add(line);
		// ambient light
		am_light = new THREE.AmbientLight( 0x444444 );
		scene.add( am_light );

		// directional light
		dir_light = new THREE.DirectionalLight( 0xFFFFFF );
		dir_light.position.set( 20, 30, -5 );
		dir_light.target.position.copy( scene.position );
		dir_light.castShadow = true;
		dir_light.shadowCameraLeft = -30;
		dir_light.shadowCameraTop = -30;
		dir_light.shadowCameraRight = 30;
		dir_light.shadowCameraBottom = 30;
		dir_light.shadowCameraNear = 20;
		dir_light.shadowCameraFar = 200;
		dir_light.shadowBias = -.001
		dir_light.shadowMapWidth = dir_light.shadowMapHeight = 2048;
		dir_light.shadowDarkness = .5;
		scene.add( dir_light );

		// Loader
		loader = new THREE.TextureLoader();
		
		// Materials
		table_material = Physijs.createMaterial(
			new THREE.MeshLambertMaterial({ map: loader.load( 'images/theydont.jpg' )}),
			.9, // high friction
			.2 // low restitution
			);
		table_material.map.wrapS = table_material.map.wrapT = THREE.RepeatWrapping;
		table_material.map.repeat.set( 5, 5 );
		
		block_material = Physijs.createMaterial(
			new THREE.MeshLambertMaterial({ map: loader.load( 'images/hunna.jpg' )}),
			0.4, // medium friction
			.4 // medium restitution
			);
		block_material.map.wrapS = block_material.map.wrapT = THREE.RepeatWrapping;
		block_material.map.repeat.set( 1, .5 );
		
		// Table
		table = new Physijs.BoxMesh(
			new THREE.BoxGeometry(50, 1, 50),
			table_material,
			0, // mass
			{ restitution: .2, friction: .8 }
			);
		table.position.y = -.5;
		table.receiveShadow = true;
		scene.add( table );
		
		createTower();
		init_bone_meshes();
		for (var i = 0; i < boneMeshes.length; i++) {
			boneMeshes[i].receiveShadow = false;
			boneMeshes[i].castShadow = true;
			scene.add(boneMeshes[i]);
			
		}
		intersect_plane = new THREE.Mesh(
			new THREE.PlaneGeometry( 150, 150 ),
			new THREE.MeshBasicMaterial({ opacity: 0, transparent: true })
			);
		intersect_plane.rotation.x = Math.PI / -2;
		scene.add( intersect_plane );
		requestAnimationFrame( render );
		scene.simulate();
	}
	init_world = function() {
		init_renderer();
		init_camera();
		init_effect();

		controls = new THREE.FirstPersonControls( camera );
		controls.movementSpeed = 40;
		controls.lookSpeed = 0.1;
		controls.lookVertical = true;
		oculuscontrol = new THREE.OculusControls( camera );
		
		init_stats();

		init_scene();
		
		window.addEventListener( 'resize', onWindowResize, false );
		document.addEventListener('keydown', keyPressed, false);
		//oculuscontrol.connect();//presumably engages oculus tracking
		//initEventHandling();
		
	};
	//from the effect demo
	function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		// realcamera.aspect = window.innerWidth / window.innerHeight;
		//realcamera.updateProjectionMatrix();
		effect.setSize( window.innerWidth, window.innerHeight );
		controls.handleResize();
	}
	
	var _vector = new THREE.Vector3,
	handleMouseDown, handleMouseMove, handleMouseUp;
	function calcvelocity(pos1, pos2, t){
		return pos2.sub(pos1).divideScalar(t);
	}
	var lastpinching = false;
	function handlepinch(){
		//console.log(currentframe);
		var ray, intersections;
		// console.log(_vector);
		var hands = currentframe.hands;
		
		if(hands.length>0){
			
			var l_hand = currentframe.hands[0];
			var a = new THREE.Vector3().fromArray(l_hand.indexFinger.tipPosition).divideScalar(20);
			var tempa = new THREE.Vector3().fromArray(l_hand.indexFinger.tipPosition).divideScalar(20);
			var b = new THREE.Vector3().fromArray(l_hand.thumb.tipPosition).divideScalar(20);
			lineGeometry.vertices[0] = a;
			lineGeometry.vertices[1] = b;
			lineGeometry.verticesNeedUpdate = true;
			//console.log("A:"+a);
			//console.log("B:"+b);
			ray = new THREE.Raycaster( a, b);
			intersections = ray.intersectObjects( blocks );
			//console.log("intersections:");
			//console.log(intersections);
			//if ( intersections.length > 0 ) {
			
			if(l_hand.pinchStrength>.9){	//if we have started pinching something
				pinching = true;
			}
			else{	//if we have stopped pinching something
				pinching = false;
				if(touched_block!=null){
					var onevec = new THREE.Vector3(1,1,1);
					touched_block.setAngularFactor( onevec );
					touched_block.setAngularVelocity( onevec );
					//console.log("Relv:");
					//console.log(last_relv);
					
					if(oldpos!=null){
						var velo = calcvelocity(oldpos, tempa , 1)
						console.log("Velo");
						console.log(velo);
						touched_block.setLinearFactor( onevec );
						touched_block.applyCentralImpulse( velo.multiplyScalar(2));
					}
					oldpos = tempa;
				}
				touched_block = null;
			}
				if(pinching && touched_block!=null){
					// selected_block = intersections[0].object;
					console.log("Was successful");
					console.log(touched_block);
					touched_block.__dirtyRotation = true;
					touched_block.__dirtyPosition = true;
					touched_block.position.set( a.x, a.y, a.z );
			   		//touched_block.rotation.set(0, 90, 180);
			   		var zvec = new THREE.Vector3(0,0,0);
			   		touched_block.setAngularFactor( zvec );
			   		touched_block.setAngularVelocity( zvec );
			   		touched_block.setLinearFactor( zvec );
			   		touched_block.setLinearVelocity( zvec );
					// You may also want to cancel the object's velocity
					touched_block.setLinearVelocity(new THREE.Vector3(0, 0, 0));
					touched_block.setAngularVelocity(new THREE.Vector3(0, 0, 0));
				}
			
		//}
	}
	if(hands.length>1){

	}

};




draw_hands = function(){
	if(currentframe == 0){
		return 0;
	}
		//console.log(currentframe);
		var dat = [];
		fingers = currentframe.fingers;
		var count = 0;
		for (var i = 0; i < fingers.length; i++) {
			for (var j = 0; j < fingers[i].bones.length; j++) {
				var b = fingers[i].bones[j];
				var center = b.center();
				// console.log("Centers");
				// // console.log(boneMeshes);
				// console.log(center);
				//if(cmesh!=null){
					var cmesh = boneMeshes[count];
					//console.log("cmesh");
					//console.log(cmesh);
					cmesh.__dirtyRotation = true;
					cmesh.__dirtyPosition = true;
					cmesh.position.set( center[0]/20, center[1]/20, center[2]/20 );
				//}
		   		//cmesh.rotation.set(0, 90, 180);

				// You may also want to cancel the object's velocity
				//cmesh.setLinearVelocity(new THREE.Vector3(0, 0, 0));
				//cmesh.setAngularVelocity(new THREE.Vector3(0, 0, 0));
				count = count +1;
			}
		}
		//console.log("Count:");
		//console.log(count);
		//console.log(boneMeshes);
		
		
		


	}
	
	render = function() {
		if(currentframe !=0){
			draw_hands();
			handlepinch();
		}
		//draw_test_block();
		requestAnimationFrame( render );
		//renderer.render( scene, camera );
		//effect
		//var t = clock.getElapsedTime();
		controls.update( clock.getDelta() );		//Necessary for movement
		//oculuscontrol.update( clock.getDelta() );	//Necessary for movement
		effect.render( scene, camera );
		renderer.render( scene, camera );
		scene.simulate( undefined, 1 );
		render_stats.update();
	};
	
	createTower = (function() {
		var block_length = 6, block_height = 2, block_width = 0.5, block_offset = 2,
		block_geometry = new THREE.BoxGeometry( block_length, block_height, block_width );
		
		return function() {
			var i, j, rows =  4,
			block;
			
			for ( i = 0; i < rows; i++ ) {
				for ( j = 0; j < 3; j++ ) {
					block = new Physijs.BoxMesh( block_geometry, block_material );
					block.position.y = (block_height / 2) + block_height * i;
					if ( i % 2 === 0 ) {
						block.rotation.y = Math.PI / 2.01; // #TODO: There's a bug somewhere when this is to close to 2
						block.position.x = block_offset * j - ( block_offset * 3 / 2 - block_offset / 2 );
					} 
					else {
						block.position.z = block_offset * j - ( block_offset * 3 / 2 - block_offset / 2 );
					}
					//block.receiveShadow = true;
					//block.castShadow = true;
					scene.add( block );
					blocks.push( block );
				}
			}
			
		}
	})();
	
	
	
	function keyPressed(event) {
			if (event.keyCode === 74) { // J key
				//$("#heading").toggle();
				checking_collisions = !checking_collisions;
				console.log("Checking collisions is "+checking_collisions);
			}
		}
		function init_all(){
				// init_vars();
				init_world();
				init_leap(); 

			}
			window.addEventListener("keypress", keyPressed, false);
			window.onload = init_all;
		</script>
	</head>

	<body>
	<!-- <div id="heading">
		<h1>Jenga</h1>
		<p>Click & drag on the blocks to move them around.</p>
	</div> -->
	<div id="viewport"></div>
</body>

</html>
